<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Canada Spends Dashboard</title>
  <link rel="stylesheet" href="public/global.css">
</head>
<body>
  <div class="app">
    <header>
      <div class="top-bar">
        <div class="header-left">
          <div>
            <h1>Canada Spends Dashboard</h1>
            <p>Explore government spending data and build your own insights.</p>
          </div>
        </div>
        <div class="tabs" role="tablist" aria-label="Dashboard modes">
          <button class="tab-button active" id="tab-dashboards" type="button" data-tab="dashboards" role="tab" aria-selected="true">Dashboards</button>
          <button class="tab-button" id="tab-explore" type="button" data-tab="explore" role="tab" aria-selected="false">Explore</button>
        </div>
      </div>
    </header>

    <div class="mode-stack">
      <section class="panel tab-panel active" id="panel-dashboards" role="tabpanel" aria-labelledby="tab-dashboards">
        <div class="controls simple">
          <select id="narrow-select"></select>
        </div>
        <div class="chart-card">
          <div class="chart-meta">
            <h3 id="narrow-title">Select a dashboard</h3>
            <p class="subtitle" id="narrow-subtitle"></p>
            <p class="note" id="narrow-note"></p>
            <p class="dashboard-description" id="narrow-description"></p>
            <div class="legend" id="narrow-legend"></div>
          </div>
          <div class="chart" id="narrow-chart"></div>
        </div>
      </section>

      <section class="panel tab-panel" id="panel-explore" role="tabpanel" aria-labelledby="tab-explore">
        <div class="panel-header">
          <h2>Explore Mode</h2>
          <p>Explore any CSV, pick the grouping, series, and value fields, and toggle series on/off.</p>
        </div>
        <div class="controls">
          <div>
            <label for="open-csv">CSV Source</label>
            <select id="open-csv"></select>
          </div>
          <div>
            <label for="open-group-by">Group By</label>
            <select id="open-group-by"></select>
          </div>
          <div>
            <label for="open-series-by">Series By</label>
            <select id="open-series-by"></select>
          </div>
          <div>
            <label for="open-value-field">Value Field</label>
            <select id="open-value-field"></select>
          </div>
          <div>
            <label for="open-min-series-total">Min Series Total ($)</label>
            <input id="open-min-series-total" type="number" min="0" value="0" />
          </div>
          <div>
            <label for="open-max-series">Max Series</label>
            <input id="open-max-series" type="number" min="1" value="12" />
          </div>
          <div class="checkbox">
            <input id="open-extract-year" type="checkbox" />
            <label for="open-extract-year">Extract year from group field</label>
          </div>
        </div>
        <div class="chart-card">
          <div class="chart-meta">
            <h3 id="open-title">Explore Mode Snapshot</h3>
            <p class="subtitle" id="open-subtitle">Current $ (not inflation-adjusted)</p>
            <p class="note" id="open-note">Use the controls above to change groupings and filters.</p>
            <p class="warning" id="open-warning" style="display:none; color:#b45309; background:#fef3c7; padding:8px 12px; border-radius:8px; font-size:13px; margin-top:8px;"></p>
            <div class="legend" id="open-legend"></div>
            <div class="series-toggles" id="open-series-toggles"></div>
          </div>
          <div class="chart" id="open-chart"></div>
        </div>
      </section>
    </div>

    <footer class="source-footer">
      <div class="footer-credits">
        A project by idiom_bytes
        <a href="https://github.com/idiom-bytes/" target="_blank" rel="noopener" aria-label="GitHub" class="icon-link">
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
        </a>
        <a href="https://x.com/idiom_bytes" target="_blank" rel="noopener" aria-label="Twitter" class="icon-link">
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>
        </a>
      </div>
      <div>Source data - <a href="https://canadaspends.com/" target="_blank" rel="noopener">Canada Spends</a></div>
      <div>Create <a href="https://github.com/idiom-bytes/canada_spends_dashboard" target="_blank" rel="noopener">your own dashboard</a></div>
    </footer>
  </div>

  <!-- Tooltip for chart hover -->
  <div id="chart-tooltip" class="chart-tooltip"></div>

  <script type="module">
    // Import hyparquet for reading Parquet files in the browser
    import { parquetRead } from 'https://cdn.jsdelivr.net/npm/hyparquet/src/index.js';

    // Data files (Parquet format)
    const dataFiles = [
      "aggregated-contracts-under-10k",
      "contracts-over-10k",
      "transfers",
      "cihr_grants",
      "nserc_grants",
      "sshrc_grants",
      "global_affairs_grants"
    ];

    // Chart colors - heat gradient (red high, yellow low)
    const CHART_COLORS = [
      "#B10026", // dark red
      "#E31A1C", // red
      "#FC4E2A", // red-orange
      "#FD8D3C", // orange
      "#FEB24C", // orange-yellow
      "#FED976", // yellow
      "#FFF3B2", // light yellow
      "#FFF8CC", // pale yellow
      "#FFFCE0", // very light yellow
      "#FFFEF0", // near white
      "#FFFFF5", // lighter
      "#FFFFFA", // lightest
    ];

    function getChartColor(index) {
      return CHART_COLORS[index % CHART_COLORS.length];
    }

    const cache = new Map();

    // Load Parquet file and convert to rows
    // Note: We fetch the entire file as ArrayBuffer because GitHub Pages
    // doesn't support HTTP range requests (returns 200 instead of 206),
    // which breaks hyparquet's asyncBufferFromUrl
    async function loadParquet(name) {
      const parquetPath = `public/${name}.parquet`;
      let headers = [];
      const rows = [];

      try {
        const response = await fetch(parquetPath);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        const arrayBuffer = await response.arrayBuffer();

        await parquetRead({
          file: arrayBuffer,
          rowFormat: 'object',
          onComplete: (data) => {
            if (!data || data.length === 0) return;
            headers = Object.keys(data[0]);
            data.forEach(row => rows.push(row));
          }
        });
      } catch (err) {
        console.error(`Error loading parquet ${name}:`, err);
        throw err;
      }
      return { headers, rows };
    }

    const openState = {
      dataFile: dataFiles[0],
      groupBy: null,
      seriesBy: null,
      valueField: null,
      extractYear: false,
      minSeriesTotal: 0,
      maxSeries: 12,
      seriesVisibility: new Set()
    };

    const elements = {
      openCsv: document.getElementById("open-csv"),
      openGroup: document.getElementById("open-group-by"),
      openSeries: document.getElementById("open-series-by"),
      openValue: document.getElementById("open-value-field"),
      openExtractYear: document.getElementById("open-extract-year"),
      openMinSeries: document.getElementById("open-min-series-total"),
      openMaxSeries: document.getElementById("open-max-series"),
      openChart: document.getElementById("open-chart"),
      openLegend: document.getElementById("open-legend"),
      openSeriesToggles: document.getElementById("open-series-toggles"),
      openWarning: document.getElementById("open-warning"),
      openControls: document.querySelector("#panel-explore .controls"),
      narrowSelect: document.getElementById("narrow-select"),
      narrowChart: document.getElementById("narrow-chart"),
      narrowLegend: document.getElementById("narrow-legend"),
      narrowTitle: document.getElementById("narrow-title"),
      narrowSubtitle: document.getElementById("narrow-subtitle"),
      narrowNote: document.getElementById("narrow-note"),
      narrowDescription: document.getElementById("narrow-description"),
      narrowControls: document.querySelector("#panel-dashboards .controls"),
      tabDashboards: document.getElementById("tab-dashboards"),
      tabExplore: document.getElementById("tab-explore"),
      panelDashboards: document.getElementById("panel-dashboards"),
      panelExplore: document.getElementById("panel-explore")
    };

    function showLoading(chartEl, controlsEl, message = "Loading data...") {
      if (controlsEl) controlsEl.classList.add("loading");
      chartEl.innerHTML = `<div class="loading-overlay"><div class="spinner"></div><span>${message}</span></div>`;
      // Clear related elements
      if (elements.openLegend) elements.openLegend.innerHTML = "";
      if (elements.openSeriesToggles) elements.openSeriesToggles.innerHTML = "";
    }

    function hideLoading(controlsEl) {
      if (controlsEl) controlsEl.classList.remove("loading");
    }

    function parseCSV(text) {
      const rows = [];
      const headers = [];
      let current = "";
      let inQuotes = false;
      let row = [];

      function commitValue() {
        row.push(current);
        current = "";
      }

      for (let i = 0; i < text.length; i += 1) {
        const char = text[i];
        const next = text[i + 1];

        if (char === '"') {
          if (inQuotes && next === '"') {
            current += '"';
            i += 1;
          } else {
            inQuotes = !inQuotes;
          }
        } else if (char === ',' && !inQuotes) {
          commitValue();
        } else if ((char === '\n' || char === '\r') && !inQuotes) {
          if (char === '\r' && next === '\n') {
            i += 1;
          }
          commitValue();
          if (row.length && row.some(value => value !== "")) {
            if (!headers.length) {
              headers.push(...row);
            } else {
              const obj = {};
              headers.forEach((header, idx) => {
                obj[header] = row[idx] ?? "";
              });
              rows.push(obj);
            }
          }
          row = [];
        } else {
          current += char;
        }
      }

      if (current.length || row.length) {
        commitValue();
        if (!headers.length) {
          headers.push(...row);
        } else {
          const obj = {};
          headers.forEach((header, idx) => {
            obj[header] = row[idx] ?? "";
          });
          rows.push(obj);
        }
      }

      return { headers, rows };
    }

    function toNumber(value) {
      if (typeof value === "number") {
        return value;
      }
      if (!value) {
        return 0;
      }
      const cleaned = String(value)
        .replace(/[$,]/g, "")
        .replace(/\s+/g, "")
        .replace(/\u2212/g, "-");
      const parsed = Number(cleaned);
      return Number.isFinite(parsed) ? parsed : 0;
    }

    function extractYear(value) {
      if (!value) {
        return "Unknown";
      }
      const match = String(value).match(/(\d{4})/);
      return match ? match[1] : String(value).trim();
    }

    function formatCurrency(value) {
      if (value >= 1_000_000_000) {
        return `$${(value / 1_000_000_000).toFixed(1)}B`;
      }
      if (value >= 1_000_000) {
        return `$${(value / 1_000_000).toFixed(0)}M`;
      }
      if (value >= 1_000) {
        return `$${(value / 1_000).toFixed(0)}K`;
      }
      return `$${Math.round(value)}`;
    }

    function getSortedGroups(groups) {
      const groupsArray = Array.from(groups);
      const numeric = groupsArray.every(group => !Number.isNaN(Number(group)));
      if (numeric) {
        return groupsArray.sort((a, b) => Number(a) - Number(b));
      }
      return groupsArray.sort((a, b) => String(a).localeCompare(String(b)));
    }

    function aggregateRows(rows, config) {
      const totals = new Map();
      const seriesTotals = new Map();
      const groupSet = new Set();
      const seriesSet = new Set();

      rows.forEach(row => {
        if (config.filters?.length) {
          for (const filter of config.filters) {
            const value = row[filter.field];
            if (!filter.values.includes(value)) {
              return;
            }
          }
        }

        if (config.mapping) {
          const mapField = config.mapping.field;
          const mapValue = row[mapField];
          if (config.mapping.include?.length) {
            if (!config.mapping.include.includes(mapValue)) {
              return;
            }
          }
          if (config.mapping.includeContains?.length) {
            const matched = config.mapping.includeContains.some(item =>
              String(mapValue).toLowerCase().includes(item.toLowerCase())
            );
            if (!matched) {
              return;
            }
          }
        }

        const groupValue = config.extractYear
          ? extractYear(row[config.groupBy])
          : row[config.groupBy];
        const seriesValue = config.seriesBy ? row[config.seriesBy] : "Total";
        const value = toNumber(row[config.valueField]);

        if (!groupValue) {
          return;
        }

        groupSet.add(groupValue);
        seriesSet.add(seriesValue);

        const groupKey = String(groupValue);
        const seriesKey = String(seriesValue);

        const groupMap = totals.get(groupKey) ?? new Map();
        groupMap.set(seriesKey, (groupMap.get(seriesKey) ?? 0) + value);
        totals.set(groupKey, groupMap);

        seriesTotals.set(seriesKey, (seriesTotals.get(seriesKey) ?? 0) + value);
      });

      let seriesList = Array.from(seriesSet);
      if (config.topSeriesPerGroup && config.maxSeries) {
        const topSeries = new Set();
        totals.forEach(groupMap => {
          const ranked = Array.from(groupMap.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, config.maxSeries);
          ranked.forEach(([seriesKey]) => topSeries.add(seriesKey));
        });
        seriesList = Array.from(topSeries);
        seriesList.sort((a, b) => (seriesTotals.get(b) ?? 0) - (seriesTotals.get(a) ?? 0));
      } else {
        if (config.minSeriesTotal) {
          seriesList = seriesList.filter(series => (seriesTotals.get(series) ?? 0) >= config.minSeriesTotal);
        }
        seriesList.sort((a, b) => (seriesTotals.get(b) ?? 0) - (seriesTotals.get(a) ?? 0));
        if (config.maxSeries) {
          seriesList = seriesList.slice(0, config.maxSeries);
        }
      }

      let groups = getSortedGroups(groupSet);
      let warning = null;

      // Limit groups to prevent browser hang
      const maxGroups = config.maxGroups || 100;
      if (groups.length > maxGroups) {
        warning = `Showing ${maxGroups} of ${groups.length} groups. Select a different "Group By" field or use filters.`;
        groups = groups.slice(0, maxGroups);
      }

      const data = groups.map(group => {
        const series = {};
        const groupMap = totals.get(String(group)) ?? new Map();
        seriesList.forEach(seriesKey => {
          series[seriesKey] = groupMap.get(seriesKey) ?? 0;
        });
        return { group, series };
      });

      return { groups, series: seriesList, data, warning };
    }

    function renderLegend(container, seriesList, visibility) {
      container.innerHTML = "";
      seriesList.forEach((series, index) => {
        const item = document.createElement("div");
        item.className = "legend-item";
        const swatch = document.createElement("span");
        swatch.className = "legend-swatch";
        swatch.style.background = getChartColor(index);
        item.appendChild(swatch);
        const label = document.createElement("span");
        label.textContent = series;
        if (visibility && !visibility.has(series)) {
          label.style.textDecoration = "line-through";
          label.style.color = "#b0b0b0";
        }
        item.appendChild(label);
        container.appendChild(item);
      });
    }

    function renderSeriesToggles(container, seriesList, visibility, onChange) {
      container.innerHTML = "";
      seriesList.forEach(series => {
        const wrapper = document.createElement("label");
        wrapper.className = "series-toggle";
        const input = document.createElement("input");
        input.type = "checkbox";
        input.checked = visibility.has(series);
        input.addEventListener("change", () => onChange(series, input.checked));
        const span = document.createElement("span");
        span.textContent = series;
        wrapper.appendChild(input);
        wrapper.appendChild(span);
        container.appendChild(wrapper);
      });
    }

    // Tooltip functions
    const tooltip = document.getElementById("chart-tooltip");

    function showTooltip(event, group, series, visibility) {
      const visibleSeries = visibility
        ? series.filter(s => visibility.has(s))
        : series;

      const total = visibleSeries.reduce((sum, s) => sum + (group.series[s] ?? 0), 0);

      let html = `<div class="chart-tooltip-header">
        <span class="chart-tooltip-title">${group.group}</span>
        <span class="chart-tooltip-total">Total: ${formatCurrency(total)}</span>
      </div>`;

      visibleSeries.forEach((s, i) => {
        const value = group.series[s] ?? 0;
        if (value > 0) {
          html += `
            <div class="chart-tooltip-row">
              <span class="chart-tooltip-swatch" style="background: ${getChartColor(series.indexOf(s))}"></span>
              <span class="chart-tooltip-label">${s}</span>
              <span class="chart-tooltip-value">${formatCurrency(value)}</span>
            </div>`;
        }
      });

      tooltip.innerHTML = html;
      tooltip.classList.add("visible");
      positionTooltip(event);
    }

    function positionTooltip(event) {
      const padding = 12;
      let x = event.clientX + padding;
      let y = event.clientY + padding;

      const rect = tooltip.getBoundingClientRect();
      if (x + rect.width > window.innerWidth) {
        x = event.clientX - rect.width - padding;
      }
      if (y + rect.height > window.innerHeight) {
        y = event.clientY - rect.height - padding;
      }

      tooltip.style.left = x + "px";
      tooltip.style.top = y + "px";
    }

    function hideTooltip() {
      tooltip.classList.remove("visible");
    }

    function renderChart(container, aggregated, options = {}) {
      container.innerHTML = "";
      const width = container.clientWidth || 960;
      const height = 360;
      const margin = { top: 20, right: 20, bottom: 40, left: 60 };
      const innerWidth = width - margin.left - margin.right;
      const innerHeight = height - margin.top - margin.bottom;

      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("viewBox", `0 0 ${width} ${height}`);

      const maxValue = aggregated.data.reduce((max, group) => {
        const total = aggregated.series.reduce((sum, series) => sum + (group.series[series] ?? 0), 0);
        return Math.max(max, total);
      }, 0);

      const yScale = value => margin.top + innerHeight - (value / (maxValue || 1)) * innerHeight;
      const band = innerWidth / Math.max(1, aggregated.groups.length);
      const barWidth = band * 0.65;

      const gridLines = 4;
      for (let i = 0; i <= gridLines; i += 1) {
        const value = (maxValue / gridLines) * i;
        const y = yScale(value);
        const line = document.createElementNS(svg.namespaceURI, "line");
        line.setAttribute("x1", margin.left);
        line.setAttribute("x2", width - margin.right);
        line.setAttribute("y1", y);
        line.setAttribute("y2", y);
        line.setAttribute("class", "grid-line");
        svg.appendChild(line);

        const label = document.createElementNS(svg.namespaceURI, "text");
        label.setAttribute("x", margin.left - 8);
        label.setAttribute("y", y + 4);
        label.setAttribute("text-anchor", "end");
        label.setAttribute("class", "axis-label");
        label.textContent = formatCurrency(value);
        svg.appendChild(label);
      }

      aggregated.data.forEach((group, index) => {
        let yCursor = margin.top + innerHeight;
        const x = margin.left + index * band + (band - barWidth) / 2;
        aggregated.series.forEach((series, seriesIndex) => {
          if (options.visibility && !options.visibility.has(series)) {
            return;
          }
          const value = group.series[series] ?? 0;
          const heightValue = (value / (maxValue || 1)) * innerHeight;
          const rect = document.createElementNS(svg.namespaceURI, "rect");
          rect.setAttribute("x", x);
          rect.setAttribute("y", yCursor - heightValue);
          rect.setAttribute("width", barWidth);
          rect.setAttribute("height", heightValue);
          rect.setAttribute("fill", getChartColor(seriesIndex));
          svg.appendChild(rect);
          yCursor -= heightValue;
        });

        // Invisible hover area for the entire bar group
        const hoverArea = document.createElementNS(svg.namespaceURI, "rect");
        hoverArea.setAttribute("x", x);
        hoverArea.setAttribute("y", margin.top);
        hoverArea.setAttribute("width", barWidth);
        hoverArea.setAttribute("height", innerHeight);
        hoverArea.setAttribute("fill", "transparent");
        hoverArea.style.cursor = "pointer";
        hoverArea.addEventListener("mouseenter", (e) => {
          showTooltip(e, group, aggregated.series, options.visibility);
        });
        hoverArea.addEventListener("mousemove", positionTooltip);
        hoverArea.addEventListener("mouseleave", hideTooltip);
        svg.appendChild(hoverArea);

        const label = document.createElementNS(svg.namespaceURI, "text");
        label.setAttribute("x", x + barWidth / 2);
        label.setAttribute("y", height - 12);
        label.setAttribute("text-anchor", "middle");
        label.setAttribute("class", "axis-label");
        label.textContent = group.group;
        svg.appendChild(label);
      });

      container.appendChild(svg);
    }

    function setActiveTab(tab) {
      const isDashboards = tab === "dashboards";
      elements.panelDashboards.classList.toggle("active", isDashboards);
      elements.panelExplore.classList.toggle("active", !isDashboards);
      elements.tabDashboards.classList.toggle("active", isDashboards);
      elements.tabExplore.classList.toggle("active", !isDashboards);
      elements.tabDashboards.setAttribute("aria-selected", String(isDashboards));
      elements.tabExplore.setAttribute("aria-selected", String(!isDashboards));
    }

    async function loadData(name) {
      if (cache.has(name)) {
        return cache.get(name);
      }
      const data = await loadParquet(name);
      cache.set(name, data);
      return data;
    }

    function populateSelect(select, options, placeholder) {
      select.innerHTML = "";
      if (placeholder) {
        const option = document.createElement("option");
        option.value = "";
        option.textContent = placeholder;
        select.appendChild(option);
      }
      options.forEach(optionValue => {
        const option = document.createElement("option");
        option.value = optionValue;
        option.textContent = optionValue;
        select.appendChild(option);
      });
    }

    // Smart field selection helpers
    function findBestGroupByField(headers, rows) {
      // Prefer year-related fields for groupBy
      const yearPatterns = ['year', 'yr', 'fiscal', 'fscl', 'date'];
      for (const pattern of yearPatterns) {
        const match = headers.find(h => h.toLowerCase().includes(pattern) && !h.toLowerCase().includes('id'));
        if (match) return match;
      }
      // Avoid ID fields and high-cardinality fields
      const avoidPatterns = ['id', 'rowid', 'uuid', 'key', 'desc', 'name', 'nm', 'nml'];
      const safeField = headers.find(h => {
        const lower = h.toLowerCase();
        return !avoidPatterns.some(p => lower.includes(p));
      });
      return safeField || headers[0];
    }

    function findBestSeriesField(headers, groupByField) {
      // Prefer department/category fields for series
      const seriesPatterns = ['dept', 'org', 'ministry', 'min', 'category', 'type', 'class', 'prov'];
      for (const pattern of seriesPatterns) {
        const match = headers.find(h =>
          h.toLowerCase().includes(pattern) &&
          h !== groupByField &&
          h.toLowerCase().includes('en') // Prefer English
        );
        if (match) return match;
      }
      // Fall back to any field that's not the groupBy
      return headers.find(h => h !== groupByField) || "(none)";
    }

    function findBestValueField(headers) {
      // Prefer amount/value fields
      const valuePatterns = ['amount', 'amt', 'value', 'total', 'sum', 'cost', 'price'];
      for (const pattern of valuePatterns) {
        const match = headers.find(h => h.toLowerCase().includes(pattern));
        if (match) return match;
      }
      return headers[headers.length - 1];
    }

    async function updateOpenMode() {
      showLoading(elements.openChart, elements.openControls, "Loading data...");

      try {
        const { headers, rows } = await loadData(openState.dataFile);
        if (!openState.groupBy) {
          openState.groupBy = findBestGroupByField(headers, rows);
        }
        if (!openState.seriesBy) {
          openState.seriesBy = findBestSeriesField(headers, openState.groupBy);
        }
        if (!openState.valueField) {
          openState.valueField = findBestValueField(headers);
        }

        // Filter out useless fields like rowid
        const usableHeaders = headers.filter(h => !['rowid', 'row_id', 'id'].includes(h.toLowerCase()));

        populateSelect(elements.openGroup, usableHeaders, null);
        populateSelect(elements.openSeries, ["(none)", ...usableHeaders], null);
        populateSelect(elements.openValue, usableHeaders, null);

        elements.openGroup.value = openState.groupBy;
        elements.openSeries.value = openState.seriesBy ?? "(none)";
        elements.openValue.value = openState.valueField;
        elements.openExtractYear.checked = openState.extractYear;
        elements.openMinSeries.value = openState.minSeriesTotal;
        elements.openMaxSeries.value = openState.maxSeries;

        const seriesBy = openState.seriesBy === "(none)" ? null : openState.seriesBy;
        const aggregated = aggregateRows(rows, {
          groupBy: openState.groupBy,
          seriesBy,
          valueField: openState.valueField,
          extractYear: openState.extractYear,
          minSeriesTotal: openState.minSeriesTotal,
          maxSeries: openState.maxSeries
        });

        if (!openState.seriesVisibility.size) {
          aggregated.series.forEach(series => openState.seriesVisibility.add(series));
        }

        // Show/hide warning
        if (aggregated.warning) {
          elements.openWarning.textContent = aggregated.warning;
          elements.openWarning.style.display = "block";
        } else {
          elements.openWarning.style.display = "none";
        }

        renderLegend(elements.openLegend, aggregated.series, openState.seriesVisibility);
        renderSeriesToggles(elements.openSeriesToggles, aggregated.series, openState.seriesVisibility, (series, visible) => {
          if (visible) {
            openState.seriesVisibility.add(series);
          } else {
            openState.seriesVisibility.delete(series);
          }
          renderLegend(elements.openLegend, aggregated.series, openState.seriesVisibility);
          renderChart(elements.openChart, aggregated, { visibility: openState.seriesVisibility });
        });

        renderChart(elements.openChart, aggregated, { visibility: openState.seriesVisibility });
      } finally {
        hideLoading(elements.openControls);
      }
    }

    function wireOpenControls() {
      populateSelect(elements.openCsv, dataFiles, null);
      elements.openCsv.value = openState.dataFile;
      elements.openCsv.addEventListener("change", async event => {
        openState.dataFile = event.target.value;
        openState.groupBy = null;
        openState.seriesBy = null;
        openState.valueField = null;
        openState.seriesVisibility.clear();
        await updateOpenMode();
      });

      elements.openGroup.addEventListener("change", async event => {
        openState.groupBy = event.target.value;
        await updateOpenMode();
      });

      elements.openSeries.addEventListener("change", async event => {
        openState.seriesBy = event.target.value;
        openState.seriesVisibility.clear();
        await updateOpenMode();
      });

      elements.openValue.addEventListener("change", async event => {
        openState.valueField = event.target.value;
        await updateOpenMode();
      });

      elements.openExtractYear.addEventListener("change", async event => {
        openState.extractYear = event.target.checked;
        await updateOpenMode();
      });

      elements.openMinSeries.addEventListener("change", async event => {
        openState.minSeriesTotal = Number(event.target.value) || 0;
        openState.seriesVisibility.clear();
        await updateOpenMode();
      });

      elements.openMaxSeries.addEventListener("change", async event => {
        openState.maxSeries = Number(event.target.value) || 12;
        openState.seriesVisibility.clear();
        await updateOpenMode();
      });
    }

    async function loadDashboardConfigs() {
      const cacheBuster = `?_cb=${Date.now()}`;
      const response = await fetch("dashboard_configs.json" + cacheBuster);
      if (!response.ok) {
        throw new Error(`Failed to load dashboard configs (${response.status})`);
      }
      return response.json();
    }

    async function loadMapping(path) {
      if (!path) {
        return null;
      }
      try {
        const cacheBuster = `?_cb=${Date.now()}`;
        const response = await fetch(path + cacheBuster);
        if (!response.ok) {
          console.warn(`Failed to load mapping: ${path}`);
          return null;
        }
        return response.json();
      } catch (err) {
        console.warn(`Error loading mapping ${path}:`, err);
        return null;
      }
    }

    async function loadPreAggregated(dashboardId) {
      // Try to load pre-aggregated JSON for instant loading
      try {
        const cacheBuster = `?_cb=${Date.now()}`;
        const response = await fetch(`public/dashboards/${dashboardId}.json${cacheBuster}`);
        if (response.ok) {
          return response.json();
        }
      } catch (err) {
        console.log(`No pre-aggregated data for ${dashboardId}, falling back to CSV`);
      }
      return null;
    }

    async function updateNarrowMode(config) {
      if (!config) {
        return;
      }
      try {
        // Try pre-aggregated data first (instant loading)
        const preAggregated = await loadPreAggregated(config.id);

        let aggregated;
        let title = config.title;
        let subtitle = config.subtitle || "";
        let note = config.note || "";
        let description = config.description || "";

        if (preAggregated) {
          console.log(`Loaded pre-aggregated data for ${config.id}`);
          aggregated = preAggregated.aggregated;
          title = preAggregated.title || title;
          subtitle = preAggregated.subtitle || subtitle;
          note = preAggregated.note || note;
          description = preAggregated.description || description;
        } else {
          // Fall back to loading Parquet and aggregating in browser
          console.log(`Loading Parquet for ${config.id}...`);
          const dataName = config.csvs[0].replace('public/', '').replace('.csv', '');
          const { rows } = await loadData(dataName);
          const mapping = config.mapping ? await loadMapping(config.mapping) : null;
          aggregated = aggregateRows(rows, {
            groupBy: config.groupBy,
            seriesBy: config.seriesBy,
            valueField: config.valueField,
            extractYear: config.extractYear,
            minSeriesTotal: config.minSeriesTotal,
            maxSeries: config.maxSeries,
            topSeriesPerGroup: config.topSeriesPerGroup,
            mapping
          });
        }

        elements.narrowTitle.textContent = title;
        elements.narrowSubtitle.textContent = subtitle;
        elements.narrowNote.textContent = note;
        elements.narrowDescription.textContent = description;

        renderLegend(elements.narrowLegend, aggregated.series);
        renderChart(elements.narrowChart, aggregated);
      } catch (err) {
        console.error("Failed to update narrow mode:", err);
        elements.narrowTitle.textContent = "Error loading dashboard";
        elements.narrowNote.textContent = err.message;
        elements.narrowChart.innerHTML = "";
        elements.narrowLegend.innerHTML = "";
      }
    }

    async function wireNarrowMode() {
      const configs = await loadDashboardConfigs();
      const dashboards = configs.dashboards ?? [];
      populateSelect(
        elements.narrowSelect,
        dashboards.map(dashboard => dashboard.id),
        null
      );

      const configMap = new Map(dashboards.map(config => [config.id, config]));
      elements.narrowSelect.addEventListener("change", async event => {
        const config = configMap.get(event.target.value);
        await updateNarrowMode(config);
      });

      if (dashboards.length) {
        elements.narrowSelect.value = dashboards[0].id;
        await updateNarrowMode(dashboards[0]);
      }
    }

    async function initialize() {
      setActiveTab("dashboards");
      elements.tabDashboards.addEventListener("click", () => setActiveTab("dashboards"));
      elements.tabExplore.addEventListener("click", () => setActiveTab("explore"));

      // Initialize narrow mode first (dashboards tab is default)
      try {
        await wireNarrowMode();
      } catch (err) {
        console.error("Failed to initialize narrow mode:", err);
      }

      // Initialize explore mode separately so errors don't block narrow mode
      try {
        wireOpenControls();
        await updateOpenMode();
      } catch (err) {
        console.error("Failed to initialize open mode:", err);
      }
    }

    initialize();
  </script>
</body>
</html>
